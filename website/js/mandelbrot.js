function makeMandelbrot() {       var element = document.getElementById('MandelbrotCanvas');    var ctx = element.getContext('2d');    var topLeft = new bound(new CNum(-2, -1), new Coord(0,0));;    var bottomRight = new bound(new CNum(1, 1), null);    var mouseDownCoord, mouseUpCoord, mousePressed = false;    var colour = new RGB(100, 131, 255), portionOfScreen = 0.4, imgData, stateStack = [], currentImage = -1;    var minIterations, maxIterations;    //Javascript bug requires hard coding (*3), (*2)    var width = 330 * 3;    var height = 330 * 2;    var heightWidthRatio = height / width;    var set, iterationsOrMagnitude = true;        initialiseMandelbrot()    $('.w3-btn').click(function() {      currentImage = -1;      reloadState(stateStack[0]);      stateStack = [];      initialiseMandelbrot();    });    element.addEventListener('mousedown', function(e){      rect = element.getBoundingClientRect();      mouseDownCoord = new Coord(e.clientX - rect.left, e.clientY - rect.top);      mousePressed = true;    }, false);    element.addEventListener('mousemove', function(e){      if (mousePressed) {        rect = element.getBoundingClientRect();        mouseUpCoord = new Coord(e.pageX - rect.left, e.pageY - rect.right);        ctx.putImageData(imgData,0,0);        //Box fitting        var xDiff = (mouseUpCoord.x - mouseDownCoord.x) + 1;        var yDiff = (mouseUpCoord.y - mouseDownCoord.y);        if ((yDiff / xDiff) < heightWidthRatio) {          xDiff = yDiff / heightWidthRatio;          mouseUpCoord.x = mouseDownCoord.x + xDiff;        } else {          yDiff = heightWidthRatio * xDiff;          mouseUpCoord.y = mouseDownCoord.y + yDiff;        }        ctx.fillStyle="gray";        ctx.fillRect(mouseDownCoord.x, mouseDownCoord.y, xDiff, yDiff);        mouseUpCoord.x = mouseDownCoord.x + xDiff;        mouseUpCoord.y = mouseDownCoord.y + yDiff;        ctx.globalAlpha=0.2;        ctx.stroke();      }    }, false);    element.addEventListener('mouseup', function(e){        mousePressed = false;        //Allows for zoom dragging from left to right or right to left        if (mouseUpCoord.y < mouseDownCoord.y) {          var tempSwap = mouseDownCoord;          mouseDownCoord = mouseUpCoord;          mouseUpCoord = tempSwap;        }        //Calculate new bounds        var temptopLeft =     new bound(coordinatesToAxis(mouseDownCoord), mouseDownCoord);        var tempbottomRight = new bound(coordinatesToAxis(mouseUpCoord), mouseUpCoord);        topLeft = temptopLeft;        bottomRight = tempbottomRight;        //Draw again with new bounds        initialiseMandelbrot();      }, false);            //Allows for flicking between previous zoom states    document.addEventListener('keydown', function(e) {     if (e.keyCode == 37) { //Left arrow       if (currentImage - 1 >= 0) {         currentImage --;         reloadState(stateStack[currentImage]);       }            } else if (e.keyCode == 39) { //Right arrow       if (currentImage + 1 < stateStack.length) {         currentImage ++;         reloadState(stateStack[currentImage]);       }     }    }, false);        function initialiseMandelbrot() {      element.height = height;      element.width = width;      minIterations = 255;      maxIterations = 0;      set = calculateSet([]);      drawSet(0, 0, width, height);    }    //Uses the 2D array from 'calculateSet' to draw an image, putting it on canvas    function drawSet(xStart, yStart, xEnd, yEnd){        imgData = ctx.createImageData(xEnd,yEnd);              var dampener = 3.3; //Dampener purely for visual effects        var i = 0;      for(var y = yStart; y < set[0].length; y++){        for(var x = xStart; x < set.length; x ++){              set[x][y] = stretchColour(set[x][y]);              imgData.data[4*i+0]=Math.round((colour.red / 255)*set[x][y] * dampener);              imgData.data[4*i+1]=Math.round((colour.green / 255)*set[x][y] * dampener);              imgData.data[4*i+2]=Math.round((colour.blue / 255)*set[x][y] * dampener);              imgData.data[4*i+3]=200;          i ++;        }      }      ctx.putImageData(imgData,xStart,yStart);      stateStack.push(new imageState(imgData, topLeft, bottomRight));      currentImage ++;    }    //Provides greatest colour contrast between divergent/convergent complex numbers    function stretchColour(val) {      return (val - minIterations) / (1 - (minIterations / 255));    }    //Returns a 2D array, with set[x][y] detailing number of iterations required by coordinate (x, y)    function calculateSet(set) {      var tempCoord, tempCNum, vec;      for (var x = 0; x < width; x++) {        vec = [];        for (var y = 0; y < height; y++) {          tempCoord = new Coord(x, y);          tempCNum = coordinatesToAxis(tempCoord);                      vec.push(iterate(tempCNum));          if (vec[y] < minIterations) {            minIterations = vec[y];          }          if (vec[y] > maxIterations) {            maxIterations = vec[y];          }        }        set.push(vec);      }      return set;    }    //Takes a complex number, c, and iterates it through z[n+1] = (z[n])^2 + c    function iterate(c) {      var tempZ = new CNum(0,0), Z = new CNum(0,0);      var valueLimit = 4, iterations = 0, iterationLimit = 255;      while((Z.Re*Z.Re+Z.Im*Z.Im) < valueLimit && iterations < iterationLimit){        tempZ.Re = Z.Re * Z.Re - Z.Im * Z.Im + c.Re        tempZ.Im = 2 * Z.Re * Z.Im + c.Im        Z.Re = tempZ.Re        Z.Im = tempZ.Im        iterations ++      }            if (iterationsOrMagnitude) {        return iterations;      } else {        return Z.Re * Z.Re + Z.Im * Z.Im;      }    }            function coordinatesToAxis(coordinates){      var sliderScale = width / (bottomRight.axis.Re - topLeft.axis.Re);      return(new CNum((coordinates.x / sliderScale) + topLeft.axis.Re                     ,(coordinates.y / sliderScale) + topLeft.axis.Im));    }    function axisToCoordinates(axisCoords){      var sliderScale = width / (bottomRight.axis.Re - topLeft.axis.Re);      return (new Coord(Math.round((axisCoords.Re - topLeft.axis.Re) * sliderScale)                     ,Math.round((axisCoords.Im - topLeft.axis.Im) * sliderScale)));    }             function reloadState(state) {      topLeft = state.topLeft;      bottomRight = state.bottomRight;      ctx.putImageData(state.img, 0, 0);      imgData = state.img;    }    function imageState(img, topLeft, bottomRight) {      this.img = img;      this.topLeft = topLeft;      this.bottomRight = bottomRight;    }            function bound(axis, coord) {      this.axis = axis;      this.coord = coord;    }    function CNum(Re, Im) {      this.Re = Re;      this.Im = Im;    }    function Coord(x, y){      this.x = x;      this.y = y;    }            function RGB(red, green, blue) {      this.red = red;      this.green = green;      this.blue = blue;    }    function printCoord(coord) {      console.log("X: " + coord.x + " , Y: " + coord.y);    }    function printCNum(cnum) {      console.log("Re: " + cnum.Re + " , Im: " + cnum.Im);    }}